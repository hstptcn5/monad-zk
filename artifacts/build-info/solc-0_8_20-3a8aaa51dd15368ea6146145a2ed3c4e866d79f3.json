{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-3a8aaa51dd15368ea6146145a2ed3c4e866d79f3",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/MonadPriceGuard.sol": "project/contracts/MonadPriceGuard.sol",
    "contracts/Verifier.sol": "project/contracts/Verifier.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/MonadPriceGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./Verifier.sol\"; // The contract generated by EZKL\r\n\r\ncontract MonadPriceGuard {\r\n    Verifier public verifier;\r\n    address public owner;\r\n\r\n    event PredictionVerified(address indexed prover, uint256[] inputs, uint256[] output, uint256 timestamp);\r\n\r\n    constructor(address _verifierAddress) {\r\n        verifier = Verifier(_verifierAddress);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function verifyPrediction(\r\n        uint256[] calldata instances, /* Public inputs/outputs */\r\n        bytes calldata proof\r\n    ) public returns (bool) {\r\n        // On Monad, this execution is extremely fast and cheap\r\n        // instances[0...n] usually contains the output (prediction) and inputs if public\r\n        \r\n        try verifier.verify(instances, proof) {\r\n            // Verification successful\r\n            emit PredictionVerified(msg.sender, instances, instances, block.timestamp);\r\n            return true;\r\n        } catch {\r\n            revert(\"ZK Proof verification failed\");\r\n        }\r\n    }\r\n}\r\n\r\n"
      },
      "project/contracts/Verifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * Mock Verifier Contract (Template)\r\n * \r\n * This is a template Verifier contract for demonstration purposes.\r\n * In production, this would be auto-generated by EZKL from your VK.\r\n * \r\n * The real EZKL-generated Verifier would contain:\r\n * - KZG commitment verification logic\r\n * - Halo2 proof verification\r\n * - Public input/output validation\r\n */\r\ncontract Verifier {\r\n    /**\r\n     * Verify a ZK proof\r\n     * @param instances Public inputs/outputs (e.g., [predicted_price, input1, input2, input3])\r\n     * @param proof The ZK proof bytes\r\n     * @return true if proof is valid\r\n     */\r\n    function verify(\r\n        uint256[] calldata instances,\r\n        bytes calldata proof\r\n    ) external pure returns (bool) {\r\n        // MOCK IMPLEMENTATION FOR DEMO\r\n        // In production, this would verify:\r\n        // 1. KZG commitments match the proof\r\n        // 2. Polynomial evaluations are correct\r\n        // 3. Public inputs/outputs are consistent\r\n        \r\n        // For demo: accept any proof with valid structure\r\n        require(instances.length > 0, \"No public inputs\");\r\n        require(proof.length > 0, \"Empty proof\");\r\n        \r\n        // In real implementation, this would perform:\r\n        // - Pairing checks for KZG commitments\r\n        // - Polynomial evaluation verification\r\n        // - Public input consistency checks\r\n        \r\n        return true; // Mock: always return true for demo\r\n    }\r\n    \r\n    /**\r\n     * Get the verification key hash (for reference)\r\n     * In production, this would return the actual VK hash\r\n     */\r\n    function getVerificationKeyHash() external pure returns (bytes32) {\r\n        return keccak256(\"MOCK_VK_HASH_FOR_DEMO\");\r\n    }\r\n}\r\n\r\n"
      }
    }
  }
}